js代码分为两种类型:
+ 全局代码(在所有函数外部定义)
+ 函数代码，位于函数内部
> js引擎执行代码时候，每一条语句都处于特定的执行上下文中

执行上下文
+ 全局上下文 (全局执行上下文只有一个，js程序开始执行就已经创建了全局上下文)
+ 函数执行上下文 (是在每次调用函数时，创建一个新的执行上下文)

 > 注意:函数上下文与函数执行上下文是不一样的概念
 
 执行上下文是js内部概念，js使用执行上下文来跟踪函数的执行
 
 
 js是单线程执行模式，在某个特定的时刻只能执行特定的代码，一旦发生函数调用，当前的执行上下文必须停止执行，并创建新的函数执行上下文来执行函数，当函数执行完成后，将函数执行上下文销毁，并重新回到发生调用时的执行上下文中。
 
 执行的上下文
 
 + 正在执行的上下文
 + 正在等待的上下文
 

通过执行上下文来跟踪代码 (跟踪方法就是使用执行上下文[调用栈])

全局代码执行是在栈内存中，原始值也是存在栈内存中？？？

全局上下文EC(G)中有一个VO(G)全局变量对象，存储全局上下文中声明的变量
[基于let/const声明的变量放在这里的，基于var/function声明的变量是直接存储到GO中也就是全局对象Window中]

```
var a = '杨紫';
dir(window) 可查看a在其中

let/const a='杨紫';
需通过作用域中的块级作用域中查看[Sources 中的Scope中的Script中可找到]
```
每个js程序只创建一个全局执行上下文，并从全局执行上下文开始执行(在单页应用中每个页面只有一个全局执行上下文)。当执行全局代码时，全局执行上下文处于活跃状态

执行上下文可以跟踪代码，即应用程序的执行位置，对于标识符也是至关重要，在[静态环境??]中通过执行上下文可以准确定位[标识符??]实际指向的变量

堆内存(Heap)存储内置api  全局对象GO 比如 setTimeout setinterval


全局上下文中使用变量 ??
1、先看vo中是否有
2、在看GO是否有
如果都没有则保存：变量未被定义


a = b = 10

创建值10存储在栈中

b = 10

a = b

正常执行顺序是从右到左

遇到优先级高的，则先执行优先级高的操作(优先级指的先运行)

a.x = a = {n:2}

a.x 优先级高于a

所以会先 a.x = {n:2},a={n:2}



js中的数组操作 不需要关注扩容问题[浏览器帮我们封装处理好了]
+ 可以存储不同的数据类型值
+ 数组容量伴随存储的内容自动缩放
+ Array.prototype上提供很多数组操作的方法

数组并不是标准的数据结构，而是浏览器帮我们封装后数据结构

优势：基于索引直接进行查找和获取，效率很高
弊端：进行中间插入和删除操作时，性能非常低（容易出现塌陷和删除中间项的优化）


i++ 和++i 的区别
```
相同：都是自身累加1

不同 : 

i++ 先拿原始值运算，运算完成后再自身累加1
i=1 5+(i++) =>先5+1  再i++  (i=2)
++i   先累加1，拿累加的结果再进行运算
i =1 5+(++i) =>先i++ 再 5+2  
```
i++ 和 i+=1/i=i+1的区别
```
"++" 一定是数学运算
i="1" i++ => 2

i+=1和 i=i+1 可能出现字符串拼接
i='1' i=i+1 =>"11"
```

基本类型值没有.length和.toString()这样的属性和方法
