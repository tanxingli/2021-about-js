##### 其他转为数字类型  Number([val])

###### 一般用于浏览器的隐式转换中
+ 数学运算
```
10-"5"
浏览器会把字符串5 转换为数字5 Number(5)
```
+ isNaN
```
isNaN(true)
浏览器会隐式的把true转换为数字 Number(true)=>1
isNaN(1) =》 false

isNaN(0) //0是有效数字所以 =》false

isNaN(12px)
浏览器会默认的把12px转换为数字 Number(12px)=>NaN
isNaN(NaN) =>true
```
+ == 比较


###### 规则：
+ 字符串转换为数字：空字符串变为0，如果出现任何非有效数字字符，结果都是NaN
+ 布尔值转为数字： true->1 false->0
+ Symbol不能转为数字，会报错
+ null-> 0  undefind=>NaN
+ bigInt去除“n”(超过安全数字的，会按照科学计数法处理)
+ 把对象转为数字：
     + 先调用对象的Symbol.toPrimitive这个方法，如果不存在这个方法
     + 再调用对象的valueof获取原始值，如果获取的值不是原始值
     + 再调用对象的toString把其变为字符串
     + 最后再把字符串基于Number方法转换为数字


注：
+ 如果对象调用toString是不会走Symbol.toPrimitive以及后面四个流程的，因为它已经不是类型转换了而是检测类型 Object.Prototype.call(),返回的是字符串
+ 如果是数组直接调用了toString是不会走Symbol.toPrimitive以及后面四个流程的，直接调它内部方法(原型的方法,方法内部会自己处理好),直接把数组变为字符串 如 var arr = [10,12];arr.toString();//"10,12"


```
let obj = {
    name:'杨紫'
}
console.log(Number(obj);

//obj[Symbol.toPrimitive]=>undefined
//obj.valueof =>{name:'杨紫'}  不是原始值
//obj.toString-> "[object Object]"
//Number("[object Object]") //NaN

var arr1 = [10],arr2 = [10,20];
console.log(Number(arr1))
//arr1[Symbol.toPrimitive]=>undefined
//arr1.valueof =>undefined
//arr1.toString-> '10'
//Number('10') 
//都没有Symbol.toPrimitive
//valueof获取的都不是原始值
//toSting ->10/10,20
//Number() =>10/NaN


let time = new Date();
console.log(Number(time);
//time[Symbol.toPrimitive]=>function
//time[Symbol.toPrimitive]() 执行它
//因为打印的时候是希望转成数字 则time[Symbol.toPrimitive]('number');

//执行方法传递值hint:number/string/default 浏览器隐式操作的
time[Symbol.toPrimitive]('number');
日期对象不让我们重写Symbol.toPrimitive


let obj={
    name:"杨紫",
    [Symbol.toPrimitive](hint){
        console.log(hint)//
        return '10px'
    }
};
console.log(Number(obj)//hint->number  Number(10px)
console.log(String(obj)//hint->string  String(10px)
obj.toSting()//"[object Object]"   Object.prototype.call(obj) 这不是把它转换为字符串 而是检测数据类型，所以不走Symbol.toPrimitive这一套逻辑


let arr = [10];
arr[Symbol.toPrimitive] = function(hint){
    console.log(hint);
    return 0
}
console.log(arr.toString())//10
console.log(arr + "");//需要把arr隐式转换为字符串【需要走Symbol.toPrimitive这套逻辑 hint->'defalut'】再进行拼接

只有Number()才会走Symbol.toPrimitive这套流程
```

######  精度丢失问题
```
```
当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候，会出现位数无限循环的情况。
js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。
在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。
当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。

对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。

我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON
```
 //精度丢失问题

        //获取系数
        var coefficient = function(num) {
                num = num + '';
                var arr = num.split('.')[1] || [],
                    len = arr.length || 0;
                return Math.pow(10, len);
            }
            //求和
        var plus = function(num1, num2) {
            //浮点数 乘除加减都会涉及到精度丢失问题
            num1 = +num1;
            num2 = +num2;
            if (isNaN(num1) || isNaN((num2))) {
                return NaN
            }
            var coeffic = Math.max(coefficient(num1), coefficient(num2));
            console.log(coeffic)
                // num1 = Number(num1.toString().replace('.', ''));
                // num2 = Number(num2.toString().replace('.', ''));
            console.log(num1, num2, num1 * coeffic, num2 * coeffic)
            return (num1 * coeffic + num2 * coeffic) / coeffic;
        }
        console.log(plus(223, 11.8944444))
```
##### 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？
```
解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Nu
mber ()）不允许出现非数字字符，否则会失败并返回 NaN。
```