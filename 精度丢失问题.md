######  精度丢失问题

```
当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候，会出现位数无限循环的情况。
js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。
在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。
当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。

对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。

我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON
```
 //精度丢失问题

        //获取系数
        var coefficient = function(num) {
                num = num + '';
                var arr = num.split('.')[1] || [],
                    len = arr.length || 0;
                return Math.pow(10, len);
            }
            //求和
        var plus = function(num1, num2) {
            //浮点数 乘除加减都会涉及到精度丢失问题
            num1 = +num1;
            num2 = +num2;
            if (isNaN(num1) || isNaN((num2))) {
                return NaN
            }
            var coeffic = Math.max(coefficient(num1), coefficient(num2));
            console.log(coeffic)
                // num1 = Number(num1.toString().replace('.', ''));
                // num2 = Number(num2.toString().replace('.', ''));
            console.log(num1, num2, num1 * coeffic, num2 * coeffic)
            return (num1 * coeffic + num2 * coeffic) / coeffic;
        }
        console.log(plus(223, 11.8944444))
```

```
精度丢失的全过程
  //精度丢失过程
        // 0.1 是10进制 => 2 进制
        // 0.1 * 2-- -- - > 0.2-- -- -- -- --0
        // 0.2 * 2-- -- - > 0.4-- -- -- -- --0
        // 0.4 * 2-- -- - > 0.8-- -- -- -- --0
        // 0.8 * 2-- -- - > 1.6-- -- -- -- --1
        // 0.6 * 2-- -- - > 1.2-- -- -- -- --1
        // 0.2 * 2-- -- - > 0.4-- -- -- -- --0
        // 0.4 * 2-- -- - > 0.8-- -- -- -- --0
        // 0.8 * 2-- -- - > 1.6-- -- -- -- --1
        // 0.6 * 2-- -- - > 1.2-- -- -- -- --1
        // 0.2 * 2-- -- - > 0.4-- -- -- -- --0
        // 0.4 * 2-- -- - > 0.8-- -- -- -- --0
        // ...... 无限循环   
        //000110011001100110011001100110011001100110... 
        // 双精度浮点数一共占据64位： 符号位（sign）占用1位 + 指数位（exponent）占用11位 + 小数位（fraction）占用52位
        //这里的符号位、指数位、小数位是和科学记数法联系在一起的所以需要把二进制转为科学计数法
        //移位  000110011001100110011001100110011001100110...要移4位
        // 1.10011001100110011001100110011001100110... *2^-4
        //符号S  指数E 有效数字M  =>  s 0因为是正数 E为 -4  有效数字 1.10011001100110011001100110011001100110...
        // 前面说过，1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。
        // 这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字
        // 首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，
        // E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
        // 所以 - 4 - 1023 = -1027
```