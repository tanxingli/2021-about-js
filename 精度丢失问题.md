######  精度丢失问题

```
当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候，会出现位数无限循环的情况。
js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。
在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。
当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。

对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。

我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON
```
 //精度丢失问题

        //获取系数
        var coefficient = function(num) {
                num = num + '';
                var arr = num.split('.')[1] || [],
                    len = arr.length || 0;
                return Math.pow(10, len);
            }
            //求和
        var plus = function(num1, num2) {
            //浮点数 乘除加减都会涉及到精度丢失问题
            num1 = +num1;
            num2 = +num2;
            if (isNaN(num1) || isNaN((num2))) {
                return NaN
            }
            var coeffic = Math.max(coefficient(num1), coefficient(num2));
            console.log(coeffic)
                // num1 = Number(num1.toString().replace('.', ''));
                // num2 = Number(num2.toString().replace('.', ''));
            console.log(num1, num2, num1 * coeffic, num2 * coeffic)
            return (num1 * coeffic + num2 * coeffic) / coeffic;
        }
        console.log(plus(223, 11.8944444))
```