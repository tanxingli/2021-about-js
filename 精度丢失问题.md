######  精度丢失问题
##### 精度丢失的全过程

```
  所有的数据类型在计算机中存储都是以二进制方式存储的，而浏览器一般认为数字是10进制，数字运算一般会先转为二进制进行运算所以第一步就是进行进制转换
1、10进制转为2进制
        // 0.1 是10进制 => 2 进制
        // 0.1 * 2-- -- - > 0.2-- -- -- -- --0
        // 0.2 * 2-- -- - > 0.4-- -- -- -- --0
        // 0.4 * 2-- -- - > 0.8-- -- -- -- --0
        // 0.8 * 2-- -- - > 1.6-- -- -- -- --1
        // 0.6 * 2-- -- - > 1.2-- -- -- -- --1
        // 0.2 * 2-- -- - > 0.4-- -- -- -- --0
        // 0.4 * 2-- -- - > 0.8-- -- -- -- --0
        // 0.8 * 2-- -- - > 1.6-- -- -- -- --1
        // 0.6 * 2-- -- - > 1.2-- -- -- -- --1
        // 0.2 * 2-- -- - > 0.4-- -- -- -- --0
        // 0.4 * 2-- -- - > 0.8-- -- -- -- --0
        // ...... 无限循环   
        //000110011001100110011001100110011001100110... 
        // 双精度浮点数一共占据64位： 符号位（sign）占用1位 + 指数位（exponent）占用11位 + 小数位（fraction）占用52位
        //这里的符号位、指数位、小数位是和科学记数法联系在一起的所以需要把二进制转为科学计数法
        2、计算指数位

        //移位  000110011001100110011001100110011001100110...要移4位
        // 1.10011001100110011001100110011001100110... *2^-4
        //向左移动几位就加几位,向右移动几位就减几位
        //符号S  指数E 有效数字M  =>  s 0因为是正数 E为 -4  有效数字 1.10011001100110011001100110011001100110...
        // 前面说过，1≤M<2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。
        // 这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字
        // 首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，
        // E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
        // 所以 1023 - 4 = 1019  
       //E   1019 转二进制并补齐11位  01111111011
       3、截取小数位  精度丢失
       //由于尾数位最多只有52位,所以小数点后面的52位全部提取到尾数位,其中要注意的是,类似四舍五入,如果末位后是1会产生进位,这里就产生了进位
    
    4、加法计算过程中是否也会精度丢失?
       解决办法:
 1、对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。但是浮点数乘法也会精度丢失如：


我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以使用 es6 的 Number.EPSILON 
 
```

 ###### 可能解决的办法
```


        //获取系数
        var coefficient = function(num) {
                num = num + '';
                var arr = num.split('.')[1] || [],
                    len = arr.length || 0;
                return Math.pow(10, len);
            }
            //求和
        var plus = function(num1, num2) {
            //浮点数 乘除加减都会涉及到精度丢失问题
            num1 = +num1;
            num2 = +num2;
            if (isNaN(num1) || isNaN((num2))) {
                return NaN
            }
            var coeffic = Math.max(coefficient(num1), coefficient(num2));
            console.log(coeffic)
                // num1 = Number(num1.toString().replace('.', ''));
                // num2 = Number(num2.toString().replace('.', ''));
            console.log(num1, num2, num1 * coeffic, num2 * coeffic)
            return (num1 * coeffic + num2 * coeffic) / coeffic;
        }
        console.log(plus(223, 11.8944444))
```
大数问题，两个数字相加他们的和可能超出最大值,要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多。所以原生支持大数就很有必要了 高版本用bigInt