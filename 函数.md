###### 函数创建
+ 开辟一个堆内存空间[16进制地址]
+ 存储的内容
   + 创建作用域[[scope]]，在哪个上下文中创建，作用域就是哪个上下文
   + 函数体代码字符串
   + 普通对象，存放键值对 如：length/name
+ 把空间地址赋值给变量(或者函数名)
> 函数创建的时候就声明了它的作用域

什么是作用域呢?

```
作用域用于存储变量，并方便后期可以找到这些变量的一套规则
常见的作用域主要分为几个类型：全局作用域、函数作用域、块状作用域、动态作用域(this)???。
---
  负责收集并维护所有声明的标识符(变量)组成的一系列查询、并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

```
###### 函数执行
+ 生成一个全新的执行上下文 EC
+ 执行代码前
   + 初始化作用域链 <自己的，上级的>
   + 初始化this
   + 初始化 arguments
   + 形参赋值
   + 变量提升
+ 代码执行
+ 出栈

> 形参和当前上下文中声明的变量是私有的

作用域链

```
自己私有上下文，作用域(上级上下文)
1、在私有上下文中遇到个变量，首先看是否为私有变量[AO中是否有] 如果是私有变量，则接下来操作的都是私有的变量[和外界没有任何直接关系]
2、如果不是自己私有的，则去上级上下文中查找，如果上级上下文中有，则操作的上级的
3、如果不是上级的则继续向上查找，...直到找到EC(G)为止
4、如果EC(G)中也没有，则
   + 如果是获取变量值，则会报错
   + 如果是设置变量值，则相当于给window设置对应的属性


一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。
但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。
```

块级作用域
```
由 let/const/function/Class 生成的块级作用域 是没有初始化this(?????)\初始化 arguments\形参赋值 
```
